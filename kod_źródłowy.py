# -*- coding: utf-8 -*-
"""kod_źródłowy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wxwep0cjvsUxZG-pvllJaXaC1NzDspH1
"""

!pip install ultralytics #instalacja biblioteki potrzebnej do YOLO

from google.colab import files
uploaded = files.upload()

from google.colab import files
uploaded = files.upload()##pobieranie plików do Colaba

!unzip soccer_dat2.zip -d . #wypakowanie plików po anotacji

#TRENING MODELU
from ultralytics import YOLO

model = YOLO("yolov8m.pt")

model.train(
    data="/content/soccer_dat2/soccer.yaml",  #dane treningowe
    epochs=100,
    imgsz=1920,   # potrzebuje dużo RAM ale Colab sobie radzi
    batch=4
)

from ultralytics import YOLO
import cv2
from collections import defaultdict, Counter

# model, wideo do trenowania i sciezka zapisu
model = YOLO("/content/best.pt")
input_video = "/content/dane.mp4"
out_path = "/content/wynik_implementacji.mp4"

# odczyt fps z wideo wejściowego
cap = cv2.VideoCapture(input_video)
fps = cap.get(cv2.CAP_PROP_FPS)
cap.release()

# uruchomienie trackingu
results = model.track(
    source=input_video,
    tracker="bytetrack.yaml",
    persist=True,
    save=False,
    stream=True
)

# pobranie pierwszej klatki
first = next(results)
h, w = first.orig_img.shape[:2]

writer = cv2.VideoWriter(
    out_path,
    cv2.VideoWriter_fourcc(*'mp4v'),
    fps,
    (w, h)
)

VOTE_FRAMES = 5
id_votes = defaultdict(list)
id_final_class = {}

# ustawienia wizualne
FONT_SCALE = 0.4
THICKNESS = 1

# zapis pierwszej klatki
frames_iter = [first] + list(results)

# główna pętla przetwarzania klatek
for r in frames_iter:
    frame = r.orig_img.copy()

    if r.boxes.id is None:
        writer.write(frame)
        continue

    ids = r.boxes.id.int().cpu().tolist()
    classes = r.boxes.cls.int().cpu().tolist()
    boxes = r.boxes.xyxy.cpu().numpy()

    for box, pid, cls in zip(boxes, ids, classes):
        x1, y1, x2, y2 = map(int, box)

        # ustalenie stabilności klasy po 5 klatkach w celu zmniejszenia zmienności
        if pid not in id_final_class:
            id_votes[pid].append(cls)
            if len(id_votes[pid]) == VOTE_FRAMES:
                id_final_class[pid] = Counter(id_votes[pid]).most_common(1)[0][0]

        # bez ustalonej klasy – brak wizualizacji
        if pid not in id_final_class:
            continue

        label = model.names[id_final_class[pid]]

        # dobór koloru na podstawie klasy
        if label == "player_red":
            color = (0, 0, 255)
        elif label == "player_yellow":
            color = (0, 255, 255)
        else:
            color = (200, 200, 200)

        # rysowanie ramek i etykiety
        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
        cv2.putText(frame, label, (x1, y1 - 5),
                    cv2.FONT_HERSHEY_SIMPLEX, FONT_SCALE, color, THICKNESS)

    writer.write(frame)

writer.release()

from ultralytics import YOLO
import cv2
from collections import defaultdict, Counter
import math
import matplotlib.pyplot as plt
import numpy as np


# model, wideo i sciezka zapisu
model = YOLO("/content/best.mp4")
input_video = "/content/dane.mp4"
out_video = "/content/wynik_implementacji.mp4"

# odczyt fps
cap = cv2.VideoCapture(input_video)
fps = cap.get(cv2.CAP_PROP_FPS)
cap.release()


# tracking
results = model.track(
    source=input_video,
    tracker="bytetrack.yaml",
    persist=True,
    save=False,
    stream=True
)


# parametry boiska
ORLIK_WIDTH_M = 30.0
METERS_PER_PIXEL = None


# parametry algorytmu
VOTE_FRAMES = 5
SPEED_UPDATE_INTERVAL = 0.3
SPEED_SMOOTH_FRAMES = 10
VECTOR_MIN_LEN = 20
VECTOR_SCALE = 12

TEAM_AVG_INTERVAL = 1.0  # średnia drużyny co 1 s lub 0,3


# struktury pomocnicze
id_votes = defaultdict(list)
id_final_class = {}

prev_centers = {}
speed_buffer = defaultdict(list)
vector_buffer = defaultdict(list)
stable_speed = defaultdict(float)
stable_vector = defaultdict(lambda: (0.0, 0.0))
frame_counter = defaultdict(int)


# dane do wykresu
avg_speed_red_series = []
avg_speed_yellow_series = []
time_axis = []
current_time = 0.0
time_accumulator = 0.0


writer = None
update_every_n_frames = None


for r in results:

    frame = r.orig_img.copy()
    time_accumulator += 1.0 / fps

    # inicjalizacja po pierwszej klatce
    if writer is None:
        h, w = frame.shape[:2]
        METERS_PER_PIXEL = ORLIK_WIDTH_M / w
        update_every_n_frames = max(1, int(fps * SPEED_UPDATE_INTERVAL))

        writer = cv2.VideoWriter(
            out_video,
            cv2.VideoWriter_fourcc(*"mp4v"),
            fps,
            (w, h)
        )

    if r.boxes.id is None:
        writer.write(frame)
        continue

    ids = r.boxes.id.int().cpu().tolist()
    classes = r.boxes.cls.int().cpu().tolist()
    boxes = r.boxes.xyxy.cpu().numpy()

    for box, pid, cls in zip(boxes, ids, classes):
        x1, y1, x2, y2 = map(int, box)

        # stabilizacja klasy zawodnika
        if pid not in id_final_class:
            id_votes[pid].append(cls)
            if len(id_votes[pid]) == VOTE_FRAMES:
                id_final_class[pid] = Counter(id_votes[pid]).most_common(1)[0][0]

        if pid not in id_final_class:
            continue

        label = model.names[id_final_class[pid]]

        cx = (x1 + x2) // 2
        cy = (y1 + y2) // 2

        # obliczenia prędkości
        if pid in prev_centers:
            dx = cx - prev_centers[pid][0]
            dy = cy - prev_centers[pid][1]
            dist = math.hypot(dx, dy)

            speed_buffer[pid].append(dist)
            vector_buffer[pid].append((dx, dy))

            if len(speed_buffer[pid]) > SPEED_SMOOTH_FRAMES:
                speed_buffer[pid].pop(0)
                vector_buffer[pid].pop(0)

            frame_counter[pid] += 1

            if frame_counter[pid] % update_every_n_frames == 0:
                avg_px = sum(speed_buffer[pid]) / len(speed_buffer[pid])
                meters = avg_px * METERS_PER_PIXEL
                stable_speed[pid] = meters * fps

                avg_dx = sum(v[0] for v in vector_buffer[pid]) / len(vector_buffer[pid])
                avg_dy = sum(v[1] for v in vector_buffer[pid]) / len(vector_buffer[pid])
                stable_vector[pid] = (avg_dx, avg_dy)

        prev_centers[pid] = (cx, cy)

        # wizualizacja
        if label == "player_red":
            color = (0, 0, 255)
        elif label == "player_yellow":
            color = (0, 255, 255)
        else:
            color = (200, 200, 200)

        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)

        speed = stable_speed[pid]
        vx, vy = stable_vector[pid]

        cv2.putText(
            frame,
            f"{label} | {speed:.1f} m/s",
            (x1, y1),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.4,
            color,
            1
        )

        norm = math.hypot(vx, vy)
        if norm > 0:
            vx /= norm
            vy /= norm

        arrow_len = VECTOR_MIN_LEN + speed * VECTOR_SCALE
        start = (cx, cy)
        end = (int(start[0] + vx * arrow_len), int(start[1] + vy * arrow_len))
        cv2.arrowedLine(frame, start, end, color, 3, tipLength=0.4)

    # średnia prędkość drużyn liczona co 1 sekundę pod wykres 0,3 można ustawic pod wideo
    if time_accumulator >= TEAM_AVG_INTERVAL:

        red_speeds = [
            v for pid, v in stable_speed.items()
            if model.names[id_final_class.get(pid, "")] == "player_red"
        ]

        yellow_speeds = [
            v for pid, v in stable_speed.items()
            if model.names[id_final_class.get(pid, "")] == "player_yellow"
        ]

        avg_red = sum(red_speeds) / len(red_speeds) if red_speeds else 0.0
        avg_yellow = sum(yellow_speeds) / len(yellow_speeds) if yellow_speeds else 0.0

        time_axis.append(current_time)
        avg_speed_red_series.append(avg_red)
        avg_speed_yellow_series.append(avg_yellow)

        current_time += TEAM_AVG_INTERVAL
        time_accumulator = 0.0

    writer.write(frame)


writer.release()

out_plot = "/content/speed_plot.png"
plt.figure(figsize=(10, 5))
plt.plot(time_axis, avg_speed_red_series, label="Drużyna czerwona", color="red")
plt.plot(time_axis, avg_speed_yellow_series, label="Drużyna żółta", color="gold")
plt.xlim(0, 170)
plt.xlabel("Czas [s]")
plt.ylabel("Średnia prędkość [m/s]")
plt.legend()
plt.grid(True)
plt.savefig(out_plot, dpi=300, bbox_inches="tight")
plt.close()

#HEATMAPY
from ultralytics import YOLO
import cv2
import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict, Counter


# pliki
MODEL_PATH = "/content/best.pt"
VIDEO_PATH = "/content/dane.mp4"
FIELD_IMAGE = "/content/boisko_czyste.png"

OUT_RED = "/content/mapa_cieplna_czerwoni.png"
OUT_YELLOW = "/content/mapa_cieplna_żółci.png"


# główne zmienne
VOTE_FRAMES = 5
BLUR = 51
INTENSITY = 850


# inicjalizacja modelu
model = YOLO(MODEL_PATH)


# start trackingu wideo
results = model.track(
    source=VIDEO_PATH,
    tracker="bytetrack.yaml",
    persist=True,
    save=False,
    stream=True
)


# rozmiar obrazu z pierwszej klatki
first = next(results)
HEIGHT, WIDTH = first.orig_img.shape[:2]


# struktury do stabilizacji klas zawodników
id_votes = defaultdict(list)
id_final_class = {}

heat_red = np.zeros((HEIGHT, WIDTH), dtype=np.float32)
heat_yellow = np.zeros((HEIGHT, WIDTH), dtype=np.float32)


# główna pętla po klatkach
frames = [first] + list(results)

for r in frames:
    if r.boxes.id is None:
        continue

    ids = r.boxes.id.int().cpu().tolist()
    classes = r.boxes.cls.int().cpu().tolist()
    boxes = r.boxes.xyxy.cpu().numpy()

    for box, pid, cls in zip(boxes, ids, classes):
        x1, y1, x2, y2 = map(int, box)

        # ustalenie klasy na podstawie kilku klatek
        if pid not in id_final_class:
            id_votes[pid].append(cls)
            if len(id_votes[pid]) == VOTE_FRAMES:
                id_final_class[pid] = Counter(id_votes[pid]).most_common(1)[0][0]

        if pid not in id_final_class:
            continue

        label = model.names[id_final_class[pid]].lower()
        if not ("red" in label or "yellow" in label):
            continue

        # środek wykrycia
        cx = (x1 + x2) // 2
        cy = (y1 + y2) // 2

        if 0 <= cx < WIDTH and 0 <= cy < HEIGHT:
            if "red" in label:
                heat_red[cy, cx] += 1
            else:
                heat_yellow[cy, cx] += 1


# lekkie wygładzenie i normalizacja
heat_red = cv2.GaussianBlur(heat_red, (BLUR, BLUR), 0)
heat_yellow = cv2.GaussianBlur(heat_yellow, (BLUR, BLUR), 0)

if heat_red.max() > 0:
    heat_red = heat_red / heat_red.max()

if heat_yellow.max() > 0:
    heat_yellow = heat_yellow / heat_yellow.max()


# wczytanie obrazu boiska
background = cv2.imread(FIELD_IMAGE)
background = cv2.resize(background, (WIDTH, HEIGHT))
background = cv2.cvtColor(background, cv2.COLOR_BGR2RGB)


# wizualizacja – drużyna czerwona
overlay_red = background.astype(np.float32)
overlay_red[:, :, 0] += heat_red * INTENSITY * 1.15
overlay_red = np.clip(overlay_red, 0, 255).astype(np.uint8)

plt.figure(figsize=(12, 6))
plt.imshow(overlay_red)
plt.axis("off")
plt.savefig(OUT_RED, dpi=300, bbox_inches="tight", pad_inches=0)
plt.close()


# wizualizacja – drużyna żółta
overlay_yellow = background.astype(np.float32)
overlay_yellow[:, :, 0] += heat_yellow * INTENSITY
overlay_yellow[:, :, 1] += heat_yellow * INTENSITY
overlay_yellow = np.clip(overlay_yellow, 0, 255).astype(np.uint8)

plt.figure(figsize=(12, 6))
plt.imshow(overlay_yellow)
plt.axis("off")
plt.savefig(OUT_YELLOW, dpi=300, bbox_inches="tight", pad_inches=0)
plt.close()